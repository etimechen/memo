# Java多线程

## 状态

New _尚未启动的线程处于此状态_

Runnable _在java虚拟机中执行的线程处于这种状态；当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；_

Running _当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；_

Blocked _等待监视器锁的线程处于此状态；处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态。_

根据阻塞产生的原因不同，阻塞状态又可以分为三种：
1. 等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；
2. 同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；
3. 其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

Timed_waiting _正在等待另一个线程执行某个操作且等待时间最长的线程处于此状态_

Terminated _退出的线程处于此状态_

## 线程方法

join() _让一个线程等待另一个线程完成才继续执行。如A线程中调用B线程的join()方法，则A线程被阻塞，直到B线程执行完，A才能继续执行。_

sleep() _让当前的正在执行的线程暂停指定的时间，并进入阻塞状态。在其睡眠的时间段内，该线程由于不是处于就绪状态，因此不会得到执行的机会。即使此时系统中没有任何其他可执行的线程，处于sleep()中的线程也不会执行。因此sleep()方法常用来暂停线程执行。_

yield() _当某个线程调用yiled()方法从运行状态转换到就绪状态后，CPU从就绪状态线程队列中只会选择与该线程优先级相同或优先级更高的线程去执行。_

## 对象方法

wait() _在synchronized修饰的同步代码块或方法里面调用wait()与notify/notifyAll()方法。当线程执行wait()时，会把当前的锁释放，然后让出CPU，进入等待状态_

notify() _当执行notify方法时，会唤醒随机一个处于等待该 对象锁 的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁_

notifyAll() _当执行notifyAll方法时，会唤醒所有处于等待该 对象锁 的线程，由cpu决定锁的获取者，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁_

